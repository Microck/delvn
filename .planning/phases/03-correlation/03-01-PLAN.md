---
phase: 03-correlation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/embeddings/__init__.py
  - src/embeddings/client.py
  - src/storage/search.py
  - tests/test_embeddings_smoke.py
autonomous: true
user_setup:
  - service: azure-embeddings
    why: "Optional: real embeddings for better correlation; dev fallback works without this"
    env_vars:
      - name: AZURE_OPENAI_ENDPOINT
        source: "Azure OpenAI/Foundry deployment endpoint"
      - name: AZURE_OPENAI_API_KEY
        source: "Azure OpenAI/Foundry API key"
      - name: AZURE_OPENAI_EMBEDDING_DEPLOYMENT
        source: "Deployment name for embedding model"
must_haves:
  truths:
    - "Embeddings can be produced deterministically in dev (fallback)"
    - "Threat documents can be indexed into Azure AI Search with vectors"
  artifacts:
    - path: "src/embeddings/client.py"
      provides: "Embedding client interface + fallback implementation"
    - path: "src/storage/search.py"
      provides: "Search index supports vector field + upsert"
  key_links:
    - from: "src/storage/search.py"
      to: "src/embeddings/client.py"
      via: "vector generation before upsert"
      pattern: "embed"
---

<objective>
Add an embedding client abstraction (with a dev-safe fallback) and ensure Azure AI Search indexing supports vectors.

Purpose: Provide the primitives needed for embedding-based correlation without hard-blocking on Azure model setup.
Output: Embedding client + vector-ready search index.
</objective>

<execution_context>
@/home/ubuntu/.config/opencode/get-shit-done/workflows/execute-plan.md
@/home/ubuntu/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
  @.planning/ROADMAP.md
  @.planning/REQUIREMENTS.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement EmbeddingClient with fallback hashing embeddings</name>
  <files>
src/embeddings/__init__.py
src/embeddings/client.py
  </files>
  <action>
Create `src/embeddings/client.py`:
- Define `EmbeddingClient` protocol/class with `embed(texts: list[str]) -> list[list[float]]`
- Implement `DeterministicHashEmbeddingClient(dim: int)` that maps text -> pseudo-vector deterministically (stable across runs)

Optional (only if env vars present): implement `AzureOpenAIEmbeddingClient` calling the Azure embedding deployment.

Keep the default selection logic in one place: `get_embedding_client()`.
  </action>
  <verify>python3 -c "from embeddings.client import get_embedding_client; print(type(get_embedding_client()).__name__)"</verify>
  <done>Default embedding client works with no Azure credentials</done>
</task>

<task type="auto">
  <name>Task 2: Update SearchStore to upsert vectorized threat docs</name>
  <files>src/storage/search.py</files>
  <action>
Extend `storage.search.SearchStore`:
- Ensure index schema includes `contentVector` with dimension from settings
- Add `index_threats(threats: list[UnifiedThreat])`:
  - build `content` from `UnifiedThreat.content_text()`
  - embed `content` via embedding client
  - upsert docs with `id`, `source`, `type`, `published_at`, `content`, `contentVector`

Add an explicit vector similarity query method that the correlator can call:
- `vector_query(*, query_vector: list[float], top_k: int = 10, exclude_id: str | None = None) -> list[dict]`
- It should query the configured index using the `contentVector` field and return a small list of hits with at least `{id, source, type, score}`.
- Apply an exclusion filter when `exclude_id` is set (avoid self-matches).

Do not change Cosmos behavior in this plan.
  </action>
  <verify>python3 -c "from storage.search import SearchStore; print(hasattr(SearchStore, 'index_threats') and hasattr(SearchStore, 'vector_query'))"</verify>
  <done>`SearchStore.index_threats` and `SearchStore.vector_query` exist and are ready for the correlator</done>
</task>

<task type="auto">
  <name>Task 3: Add embedding smoke tests</name>
  <files>tests/test_embeddings_smoke.py</files>
  <action>
Add tests that:
- embedding outputs have correct dimension
- embeddings are deterministic for same input
  </action>
  <verify>python3 -m pytest -q</verify>
  <done>Embedding tests pass</done>
</task>

</tasks>

<verification>
- `python3 -m pytest -q` passes
</verification>

<success_criteria>
- Threats can be prepared for vector indexing with a dev-safe embedding fallback
</success_criteria>

<output>
After completion, create `.planning/phases/03-correlation/03-01-SUMMARY.md`
</output>
